<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Neo-Tokyo Balloon Buster 2087</title>
<style>
    @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Inter:wght@300;400;600;700&display=swap');
    
    body {
        margin: 0; padding: 0;
        background: radial-gradient(circle at center, #0a0a1a, #000);
        font-family: 'Inter', sans-serif;
        overflow: hidden;
        touch-action: none;
        color: #00ffff;
    }
    #gameContainer {
        position: relative;
        width: 100vw; height: 100vh;
        background: linear-gradient(180deg, 
            #0a0a1a 0%, 
            #1a1a2e 30%, 
            #16213e 60%, 
            #0f0f23 100%);
    }
    canvas {
        display: block;
        border: 2px solid #00ffff;
        border-radius: 0;
        box-shadow: 
            0 0 20px #00ffff,
            inset 0 0 20px rgba(0, 255, 255, 0.1);
    }
    #ui {
        position: absolute;
        top: 20px; left: 20px;
        background: linear-gradient(135deg, rgba(0, 0, 0, 0.8), rgba(0, 20, 40, 0.6));
        border: 2px solid #ff0080;
        padding: 20px;
        border-radius: 0;
        color: #00ffff;
        font-family: 'Orbitron', monospace;
        font-size: 16px;
        font-weight: 700;
        backdrop-filter: blur(10px);
        box-shadow: 
            0 0 20px #ff0080,
            inset 0 0 10px rgba(255, 0, 128, 0.1);
        z-index: 10;
        text-transform: uppercase;
        letter-spacing: 2px;
    }
    #ui div {
        margin: 8px 0;
        display: flex;
        align-items: center;
        text-shadow: 0 0 10px #00ffff;
    }
    #ui span {
        color: #ff0080;
        margin-left: 10px;
        font-weight: 900;
        text-shadow: 0 0 10px #ff0080;
    }
    #difficultyPanel {
        position: absolute;
        top: 20px; right: 20px;
        background: linear-gradient(135deg, rgba(0, 0, 0, 0.8), rgba(40, 0, 20, 0.6));
        border: 2px solid #00ff80;
        padding: 20px;
        border-radius: 0;
        backdrop-filter: blur(10px);
        box-shadow: 
            0 0 20px #00ff80,
            inset 0 0 10px rgba(0, 255, 128, 0.1);
        z-index: 10;
    }
    #difficultyPanel > div {
        color: #00ffff;
        font-family: 'Orbitron', monospace;
        font-weight: 700;
        font-size: 14px;
        margin-bottom: 15px;
        text-align: center;
        text-transform: uppercase;
        letter-spacing: 2px;
        text-shadow: 0 0 10px #00ffff;
    }
    #difficultyPanel button {
        background: linear-gradient(45deg, #000, #1a1a2e);
        color: #00ffff;
        border: 2px solid #00ffff;
        padding: 12px 16px;
        font-family: 'Orbitron', monospace;
        font-size: 12px;
        font-weight: 600;
        margin: 4px;
        border-radius: 0;
        cursor: pointer;
        transition: all 0.3s ease;
        text-transform: uppercase;
        letter-spacing: 1px;
        box-shadow: 0 0 10px rgba(0, 255, 255, 0.3);
    }
    #difficultyPanel button.active {
        background: linear-gradient(45deg, #ff0080, #ff4060);
        border-color: #ff0080;
        color: #ffffff;
        box-shadow: 0 0 20px #ff0080;
        text-shadow: 0 0 10px #ffffff;
    }
    #difficultyPanel button:hover {
        transform: translateY(-2px);
        box-shadow: 0 0 15px rgba(0, 255, 255, 0.5);
        text-shadow: 0 0 10px #00ffff;
    }
    #joystick {
        position: absolute;
        bottom: 40px; left: 40px;
        width: 100px; height: 100px;
        border-radius: 50%;
        background: radial-gradient(circle, rgba(0, 255, 255, 0.2), rgba(0, 0, 0, 0.8));
        border: 3px solid #00ffff;
        backdrop-filter: blur(10px);
        box-shadow: 
            0 0 30px #00ffff,
            inset 0 0 20px rgba(0, 255, 255, 0.1);
        z-index: 10;
        touch-action: none;
    }
    #joystickKnob {
        position: absolute;
        width: 35px; height: 35px;
        border-radius: 50%;
        background: radial-gradient(circle, #ff0080, #ff4060);
        border: 2px solid #ffffff;
        box-shadow: 0 0 15px #ff0080;
        top: 50%; left: 50%;
        transform: translate(-50%, -50%);
        transition: all 0.1s;
    }
    #levelComplete, #slotMachine, #gameOver, #levelRestart {
        position: absolute;
        top: 50%; left: 50%;
        transform: translate(-50%, -50%);
        background: linear-gradient(135deg, rgba(0, 0, 0, 0.95), rgba(20, 20, 40, 0.9));
        border: 3px solid;
        border-radius: 0;
        padding: 40px 50px;
        color: #00ffff;
        text-align: center;
        z-index: 20;
        display: none;
        user-select: none;
        backdrop-filter: blur(20px);
        font-family: 'Orbitron', monospace;
        box-shadow: 0 0 40px rgba(0, 0, 0, 0.8);
    }
    #levelComplete {
        border-color: #00ff80;
        box-shadow: 0 0 40px #00ff80;
    }
    #slotMachine {
        border-color: #ffd700;
        box-shadow: 0 0 40px #ffd700;
        max-width: 90vw;
        max-height: 80vh;
        overflow-y: auto;
    }
    #gameOver {
        border-color: #ff0040;
        box-shadow: 0 0 40px #ff0040;
    }
    #levelRestart {
        border-color: #ff8000;
        box-shadow: 0 0 40px #ff8000;
    }
    
    /* FIXED: Proper slot alignment with flexbox */
    #slotOptions {
        display: flex;
        flex-direction: row;
        justify-content: center;
        align-items: stretch;
        gap: 20px;
        margin: 20px 0;
        flex-wrap: wrap;
    }
    
    .slotOption {
        display: flex;
        flex-direction: column;
        justify-content: space-between;
        align-items: center;
        width: 160px; 
        height: 180px;
        background: linear-gradient(135deg, #1a1a2e, #16213e);
        color: #00ffff;
        border-radius: 0;
        padding: 20px;
        cursor: pointer;
        border: 2px solid #00ffff;
        transition: all 0.3s ease;
        box-shadow: 0 0 20px rgba(0, 255, 255, 0.3);
        position: relative;
        overflow: hidden;
        text-transform: uppercase;
        letter-spacing: 1px;
        flex-shrink: 0;
    }
    
    .slotOption:hover:not(.spinning) {
        background: linear-gradient(135deg, #16213e, #0f0f23);
        border-color: #ffd700;
        transform: scale(1.05) translateY(-5px);
        box-shadow: 0 0 30px #ffd700;
        color: #ffd700;
    }
    
    .slotOption .icon {
        font-size: 50px;
        margin-bottom: 15px;
        filter: drop-shadow(0 0 10px currentColor);
        transition: transform 0.1s;
        flex-shrink: 0;
    }
    
    /* FIXED: More readable font for skill names and descriptions */
    .slotOption .name {
        font-family: 'Inter', sans-serif;
        font-size: 16px;
        font-weight: 700;
        text-shadow: 0 0 8px currentColor;
        margin-bottom: 10px;
        text-align: center;
        line-height: 1.2;
    }
    
    .slotOption .desc {
        font-family: 'Inter', sans-serif;
        font-size: 13px;
        font-weight: 400;
        opacity: 0.9;
        text-align: center;
        line-height: 1.3;
        text-transform: none;
        letter-spacing: 0.5px;
    }
    
    .slotOption.spinning {
        background: linear-gradient(135deg, #ffd700, #ff8000);
        border-color: #ffd700;
        color: #000;
        box-shadow: 0 0 40px #ffd700;
        cursor: not-allowed;
    }
    
    .slotOption.spinning .icon {
        animation: slotSpin 0.1s linear infinite;
    }
    
    @keyframes slotSpin {
        0% { transform: rotateY(0deg) scale(1); }
        25% { transform: rotateY(90deg) scale(0.8); }
        50% { transform: rotateY(180deg) scale(1); }
        75% { transform: rotateY(270deg) scale(0.8); }
        100% { transform: rotateY(360deg) scale(1); }
    }
    
    button {
        background: linear-gradient(45deg, #00ffff, #0080ff);
        color: #000;
        border: 2px solid #00ffff;
        padding: 15px 30px;
        font-family: 'Orbitron', monospace;
        font-size: 16px;
        font-weight: 700;
        border-radius: 0;
        cursor: pointer;
        margin: 20px;
        user-select: none;
        transition: all 0.3s ease;
        text-transform: uppercase;
        letter-spacing: 2px;
        box-shadow: 0 0 20px rgba(0, 255, 255, 0.4);
    }
    
    button:hover {
        transform: translateY(-3px);
        box-shadow: 0 0 30px #00ffff;
        background: linear-gradient(45deg, #ff0080, #ff4060);
        border-color: #ff0080;
        color: #ffffff;
    }
    
    button:disabled {
        opacity: 0.5;
        cursor: not-allowed;
        transform: none;
    }
    
    h2 {
        font-family: 'Orbitron', monospace;
        font-weight: 900;
        font-size: 28px;
        text-shadow: 0 0 20px currentColor;
        margin-bottom: 25px;
        text-transform: uppercase;
        letter-spacing: 3px;
    }
    
    p {
        font-family: 'Inter', sans-serif;
        font-size: 16px;
        text-shadow: 0 0 10px currentColor;
        margin: 15px 0;
    }
    
    /* Neon glow effects */
    @keyframes neonGlow {
        0%, 100% { text-shadow: 0 0 5px currentColor, 0 0 10px currentColor, 0 0 15px currentColor; }
        50% { text-shadow: 0 0 10px currentColor, 0 0 20px currentColor, 0 0 30px currentColor; }
    }
    .neon-text {
        animation: neonGlow 2s ease-in-out infinite alternate;
    }
</style>
</head>
<body>
<div id="gameContainer">
    <canvas id="gameCanvas"></canvas>
    <div id="ui">
        <div>‚ö° STAGE: <span id="stageNumber">1</span></div>
        <div>üéà TARGETS: <span id="balloonCount">0</span></div>
        <div>‚öôÔ∏è MODE: <span id="currentDifficulty">Medium</span></div>
        <div>üíÄ LIVES: <span id="livesCount">3</span></div>
    </div>
    <div id="difficultyPanel">
        <div>Difficulty Mode</div>
        <button onclick="setDifficulty('easy')" id="easyBtn">Novice</button>
        <button onclick="setDifficulty('medium')" id="mediumBtn" class="active">Hacker</button>
        <button onclick="setDifficulty('hard')" id="hardBtn">Ghost</button>
    </div>
    <div id="joystick" aria-label="Neural Interface" role="application">
        <div id="joystickKnob"></div>
    </div>
    
    <div id="levelComplete">
        <h2 class="neon-text">üåü SECTOR CLEARED üåü</h2>
        <p>Sector <span id="completedStage">1</span> neutralized!</p>
        <p>Targets eliminated: <span id="balloonsDestroyed">0</span></p>
        <button onclick="continueToNextLevel()">ADVANCE</button>
    </div>
    
    <div id="levelRestart">
        <h2 class="neon-text">üí• SYSTEM FAILURE üí•</h2>
        <p>Neural link lost in Sector <span id="failedStage">1</span></p>
        <button onclick="restartLevel()">RESTORE LINK</button>
        <button onclick="restartGame()">FULL REBOOT</button>
    </div>
    
    <div id="slotMachine">
        <h2 class="neon-text">üîß CYBERWARE UPGRADE üîß</h2>
        <p id="slotInstructions">Select enhancement module:</p>
        <div id="slotOptions"></div>
    </div>
    
    <div id="gameOver" role="dialog" aria-modal="true" aria-labelledby="gameOverTitle">
        <h2 id="gameOverTitle" class="neon-text">SYSTEM SHUTDOWN</h2>
        <p>Final Sector Reached: <span id="finalStage">1</span></p>
        <button onclick="restartGame()">REBOOT SYSTEM</button>
    </div>
</div>

<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

function resizeCanvas() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
}
resizeCanvas();
window.addEventListener('resize', resizeCanvas);

const difficultySettings = {
    easy: { balloonSpeed: 0.8, balloonCount: 3, balloonGravity: 0.15, name: 'Novice' },
    medium: { balloonSpeed: 1.0, balloonCount: 3, balloonGravity: 0.2, name: 'Hacker' },
    hard: { balloonSpeed: 1.4, balloonCount: 3, balloonGravity: 0.25, name: 'Ghost' }
};

let gameState = {
    stage: 1,
    difficulty: 'medium',
    balloonsDestroyed: 0,
    player: {
        x: canvas.width / 2,
        y: canvas.height - 80,
        width: 60,
        height: 60,
        speed: 5,
        moveLeft: false,
        moveRight: false,
        lastShot: 0,
        fireRate: 300,
        doubleShot: false,
        ricochet: false,
        shield: false,
        speedBoost: false,
        lives: 3,
        invulnerable: false,
        invulnerabilityTime: 0
    },
    balloons: [],
    bullets: [],
    particles: [],
    backgroundElements: [],
    joystick: { active: false, centerX: 70, centerY: window.innerHeight - 70 },
    // FIXED: Track acquired skills to prevent duplicates
    acquiredSkills: new Set(),
    allUpgrades: [
        { name: 'Dual Cannon', icon: '‚ö°', desc: 'Triple-shot system', type: 'attack' },
        { name: 'Rail Rounds', icon: '‚ÜóÔ∏è', desc: 'Ricocheting plasma', type: 'attack' },
        { name: 'Auto-Burst', icon: 'üî•', desc: 'Rapid-fire mode', type: 'attack' },
        { name: 'Force Field', icon: 'üõ°Ô∏è', desc: 'Energy barrier', type: 'defense' },
        { name: 'Overdrive', icon: 'üí®', desc: 'Speed enhancer', type: 'defense' },
        { name: 'Phase Dash', icon: '‚ö°', desc: 'Quantum movement', type: 'defense' },
        { name: 'Gravity Rev', icon: 'üåÄ', desc: 'Anti-grav field', type: 'special' },
        { name: 'Chain React', icon: 'üí•', desc: 'Cascade explosions', type: 'special' },
        { name: 'Time Dilation', icon: '‚è∞', desc: 'Temporal slowdown', type: 'special' }
    ]
};

// Background building/neon elements for Neo-Tokyo atmosphere
function initBackground() {
    gameState.backgroundElements = [];
    
    // Add neon building silhouettes
    for (let i = 0; i < 8; i++) {
        gameState.backgroundElements.push({
            type: 'building',
            x: i * (canvas.width / 7),
            y: canvas.height * 0.3,
            width: 60 + Math.random() * 40,
            height: 200 + Math.random() * 300,
            color: Math.random() > 0.5 ? '#ff0080' : '#00ffff',
            opacity: 0.1 + Math.random() * 0.2
        });
    }
    
    // Add floating neon signs
    for (let i = 0; i < 5; i++) {
        gameState.backgroundElements.push({
            type: 'sign',
            x: Math.random() * canvas.width,
            y: 100 + Math.random() * 200,
            text: ['SUSHI', 'RAMEN', 'KARAOKE', 'ARCADE', 'SHOP'][i],
            color: ['#ff0080', '#00ffff', '#ffd700', '#00ff80', '#ff4060'][i],
            glow: 0
        });
    }
}

// Cyber-themed balloon class
class CyberBalloon {
    constructor(x, y, size, vx = 0, vy = 0) {
        this.x = x;
        this.y = y;
        this.size = size;
        this.radius = size * 15 + 10;
        const settings = difficultySettings[gameState.difficulty];
        
        this.vx = vx || (Math.random() - 0.5) * 3 * settings.balloonSpeed;
        this.vy = vy || Math.random() * -8 - 4;
        
        // Cyberpunk balloon themes
        this.themes = {
            3: { color: '#ff0080', glow: '#ff0080', type: 'Security Drone' },
            2: { color: '#ffd700', glow: '#ffd700', type: 'Data Pod' }, 
            1: { color: '#00ff80', glow: '#00ff80', type: 'Nano Swarm' }
        };
        
        this.theme = this.themes[size];
        this.gravity = settings.balloonGravity;
        this.baseBounceVelocity = size === 1 ? 10 : size === 2 ? 11 : 12;
        this.energyBoost = 1.02;
        this.glowPulse = 0;
    }
    
    update() {
        this.vy += this.gravity;
        this.x += this.vx;
        this.y += this.vy;
        this.glowPulse += 0.1;
        
        // Wall bounces
        if (this.x - this.radius <= 0) {
            this.x = this.radius;
            this.vx = Math.abs(this.vx) * this.energyBoost;
        } else if (this.x + this.radius >= canvas.width) {
            this.x = canvas.width - this.radius;
            this.vx = -Math.abs(this.vx) * this.energyBoost;
        }
        
        // Floor bounce
        const floorY = canvas.height - 80;
        if (this.y + this.radius >= floorY) {
            this.y = floorY - this.radius;
            this.vy = -this.baseBounceVelocity * this.energyBoost;
        }
        
        // Ceiling bounce
        if (this.y - this.radius <= 0) {
            this.y = this.radius;
            this.vy = Math.abs(this.vy) * 0.9;
        }
    }
    
    draw() {
        const pulseIntensity = 0.3 + Math.sin(this.glowPulse) * 0.2;
        
        // Outer glow
        ctx.save();
        ctx.shadowColor = this.theme.glow;
        ctx.shadowBlur = 30 * pulseIntensity;
        ctx.globalAlpha = 0.6;
        
        // Main balloon body with cyberpunk gradient
        const gradient = ctx.createRadialGradient(
            this.x - this.radius/3, this.y - this.radius/3, 0,
            this.x, this.y, this.radius
        );
        gradient.addColorStop(0, this.theme.color);
        gradient.addColorStop(0.4, this.theme.color + '80');
        gradient.addColorStop(1, this.theme.color + '20');
        
        ctx.fillStyle = gradient;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
        
        // Holographic grid pattern
        ctx.save();
        ctx.strokeStyle = this.theme.glow;
        ctx.lineWidth = 1;
        ctx.globalAlpha = 0.4 + pulseIntensity * 0.3;
        
        // Grid lines
        for (let i = -this.radius; i <= this.radius; i += 8) {
            ctx.beginPath();
            ctx.moveTo(this.x + i, this.y - this.radius);
            ctx.lineTo(this.x + i, this.y + this.radius);
            ctx.stroke();
            
            ctx.beginPath();
            ctx.moveTo(this.x - this.radius, this.y + i);
            ctx.lineTo(this.x + this.radius, this.y + i);
            ctx.stroke();
        }
        ctx.restore();
        
        // Central core
        ctx.save();
        ctx.fillStyle = this.theme.glow;
        ctx.shadowColor = this.theme.glow;
        ctx.shadowBlur = 20;
        ctx.globalAlpha = 0.8 + pulseIntensity * 0.2;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.radius * 0.3, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
    }
    
    split() {
        if (this.size <= 1) return [];
        const newSize = this.size - 1;
        const balloon1 = new CyberBalloon(this.x - 15, this.y, newSize, -3, -8);
        const balloon2 = new CyberBalloon(this.x + 15, this.y, newSize, 3, -8);
        return [balloon1, balloon2];
    }
}

// Cyber particle effects
class CyberParticle {
    constructor(x, y) {
        this.x = x;
        this.y = y;
        this.radius = 2 + Math.random() * 3;
        this.vx = (Math.random() - 0.5) * 8;
        this.vy = (Math.random() - 0.8) * 8;
        this.alpha = 1;
        this.decay = 0.02 + Math.random() * 0.03;
        this.colors = ['#ff0080', '#00ffff', '#ffd700', '#00ff80'];
        this.color = this.colors[Math.floor(Math.random() * this.colors.length)];
        this.trail = [];
    }
    
    update() {
        this.trail.push({ x: this.x, y: this.y, alpha: this.alpha });
        if (this.trail.length > 5) this.trail.shift();
        
        this.x += this.vx;
        this.y += this.vy;
        this.alpha -= this.decay;
        this.radius *= 0.98;
    }
    
    draw() {
        // Particle trail
        ctx.save();
        this.trail.forEach((point, i) => {
            ctx.globalAlpha = point.alpha * (i / this.trail.length) * 0.5;
            ctx.fillStyle = this.color;
            ctx.shadowColor = this.color;
            ctx.shadowBlur = 15;
            ctx.beginPath();
            ctx.arc(point.x, point.y, this.radius * 0.5, 0, Math.PI * 2);
            ctx.fill();
        });
        
        // Main particle
        ctx.globalAlpha = this.alpha;
        ctx.fillStyle = this.color;
        ctx.shadowColor = this.color;
        ctx.shadowBlur = 20;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
    }
    
    isDead() {
        return this.alpha <= 0 || this.radius <= 0.5;
    }
}

// Plasma bullet class
class PlasmaBullet {
    constructor(x, y, vx = 0, vy = -8) {
        this.x = x; this.y = y;
        this.vx = vx; this.vy = vy;
        this.width = 4; this.height = 12;
        this.ricochet = gameState.player.ricochet;
        this.bounces = 0;
        this.maxBounces = 3;
        this.trail = [];
    }
    
    update() {
        this.trail.push({ x: this.x, y: this.y });
        if (this.trail.length > 8) this.trail.shift();
        
        this.x += this.vx;
        this.y += this.vy;
        
        if (this.ricochet && this.bounces < this.maxBounces) {
            if (this.x <= 0 || this.x >= canvas.width) { this.vx *= -1; this.bounces++; }
            if (this.y <= 0) { this.vy *= -1; this.bounces++; }
        }
    }
    
    draw() {
        ctx.save();
        
        // Bullet trail
        this.trail.forEach((point, i) => {
            ctx.globalAlpha = (i / this.trail.length) * 0.6;
            ctx.fillStyle = '#00ffff';
            ctx.shadowColor = '#00ffff';
            ctx.shadowBlur = 10;
            ctx.beginPath();
            ctx.arc(point.x, point.y, 2, 0, Math.PI * 2);
            ctx.fill();
        });
        
        // Main bullet
        ctx.globalAlpha = 1;
        ctx.fillStyle = '#ffffff';
        ctx.shadowColor = '#00ffff';
        ctx.shadowBlur = 15;
        ctx.beginPath();
        ctx.roundRect(this.x - this.width/2, this.y - this.height/2, this.width, this.height, 2);
        ctx.fill();
        ctx.restore();
    }
    
    isOffScreen() {
        return this.y < -10 || this.x < -10 || this.x > canvas.width + 10 ||
               (this.y > canvas.height + 10 && (!this.ricochet || this.bounces >= this.maxBounces));
    }
}

// Game controls
const keys = {};
document.addEventListener('keydown', e => {
    keys[e.key] = true;
    if (e.key === 'ArrowLeft') gameState.player.moveLeft = true;
    if (e.key === 'ArrowRight') gameState.player.moveRight = true;
});
document.addEventListener('keyup', e => {
    keys[e.key] = false;
    if (e.key === 'ArrowLeft') gameState.player.moveLeft = false;
    if (e.key === 'ArrowRight') gameState.player.moveRight = false;
});

let joystickTouchId = null;
const joystick = document.getElementById('joystick');
const joystickKnob = document.getElementById('joystickKnob');

joystick.addEventListener('touchstart', e => {
    e.preventDefault();
    if (joystickTouchId !== null) return;
    joystickTouchId = e.changedTouches[0].identifier;
    gameState.joystick.active = true;
});

joystick.addEventListener('touchmove', e => {
    if (!gameState.joystick.active) return;
    e.preventDefault();
    let touch = null;
    for (const t of e.changedTouches) {
        if (t.identifier === joystickTouchId) { touch = t; break; }
    }
    if (!touch) return;
    const rect = joystick.getBoundingClientRect();
    const centerX = rect.left + rect.width / 2;
    const centerY = rect.top + rect.height / 2;
    const deltaX = touch.clientX - centerX;
    const deltaY = touch.clientY - centerY;
    const maxDistance = 32;
    let knobX, knobY;
    const dist = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
    if (dist > maxDistance) {
        const angle = Math.atan2(deltaY, deltaX);
        knobX = Math.cos(angle) * maxDistance;
        knobY = Math.sin(angle) * maxDistance;
    } else {
        knobX = deltaX;
        knobY = deltaY;
    }
    joystickKnob.style.transform = `translate(${knobX - 17}px, ${knobY - 17}px)`;
    gameState.player.moveLeft = knobX < -10;
    gameState.player.moveRight = knobX > 10;
});

document.addEventListener('touchend', e => {
    for (const t of e.changedTouches) {
        if (t.identifier === joystickTouchId) {
            gameState.joystick.active = false;
            gameState.player.moveLeft = false;
            gameState.player.moveRight = false;
            joystickKnob.style.transform = 'translate(-17px, -17px)';
            joystickTouchId = null;
            break;
        }
    }
});

function setDifficulty(difficulty) {
    gameState.difficulty = difficulty;
    document.querySelectorAll('#difficultyPanel button').forEach(btn => btn.classList.remove('active'));
    document.getElementById(difficulty + 'Btn').classList.add('active');
    document.getElementById('currentDifficulty').textContent = difficultySettings[difficulty].name;
    if (gameState.balloons.length > 0 || gameState.stage > 1) {
        spawnBalloons(gameState.stage);
    }
}

function spawnBalloons(stage) {
    gameState.balloons = [];
    const settings = difficultySettings[gameState.difficulty];
    const baseCount = 3;
    const additionalBalloons = Math.floor((stage - 1) / 2);
    const count = Math.min(baseCount + additionalBalloons, 8);
    
    for (let i = 0; i < count; i++) {
        const x = Math.random() * (canvas.width - 200) + 100;
        const y = Math.random() * (canvas.height * 0.6) + 50;
        const size = i < 3 ? 3 : Math.floor(Math.random() * 3) + 1;
        gameState.balloons.push(new CyberBalloon(x, y, size));
    }
}

function shoot() {
    const now = Date.now();
    if (now - gameState.player.lastShot < gameState.player.fireRate) return;
    gameState.player.lastShot = now;
    const bullet1 = new PlasmaBullet(gameState.player.x, gameState.player.y - 30);
    gameState.bullets.push(bullet1);
    if (gameState.player.doubleShot) {
        const bullet2 = new PlasmaBullet(gameState.player.x - 20, gameState.player.y - 30);
        const bullet3 = new PlasmaBullet(gameState.player.x + 20, gameState.player.y - 30);
        gameState.bullets.push(bullet2, bullet3);
    }
}

function createBurstParticles(x, y) {
    for (let i = 0; i < 20; i++) {
        gameState.particles.push(new CyberParticle(x, y));
    }
}

function checkCollisions() {
    for (let i = gameState.bullets.length - 1; i >= 0; i--) {
        const bullet = gameState.bullets[i];
        let hit = false;
        for (let j = gameState.balloons.length - 1; j >= 0; j--) {
            const balloon = gameState.balloons[j];
            const dist = Math.hypot(bullet.x - balloon.x, bullet.y - balloon.y);
            if (dist < balloon.radius + 5) {
                gameState.bullets.splice(i, 1);
                gameState.balloons.splice(j, 1);
                gameState.balloonsDestroyed++;
                createBurstParticles(balloon.x, balloon.y);
                const splitBalloons = balloon.split();
                gameState.balloons.push(...splitBalloons);
                hit = true;
                break;
            }
        }
        if (hit) continue;
    }
    if (!gameState.player.shield && !gameState.player.invulnerable) {
        for (const balloon of gameState.balloons) {
            const dist = Math.hypot(gameState.player.x - balloon.x, gameState.player.y - balloon.y);
            if (dist < balloon.radius + 30) {
                gameState.player.lives--;
                gameState.player.invulnerable = true;
                gameState.player.invulnerabilityTime = Date.now() + 1000;
                if (gameState.player.lives <= 0) {
                    showLevelRestart();
                } else {
                    gameState.player.x = canvas.width / 2;
                }
                break;
            }
        }
    }
    if (gameState.player.invulnerable && Date.now() > gameState.player.invulnerabilityTime) {
        gameState.player.invulnerable = false;
    }
}

function updatePlayer() {
    const speed = gameState.player.speedBoost ? gameState.player.speed * 1.5 : gameState.player.speed;
    if (gameState.player.moveLeft) {
        gameState.player.x = Math.max(30, gameState.player.x - speed);
    }
    if (gameState.player.moveRight) {
        gameState.player.x = Math.min(canvas.width - 30, gameState.player.x + speed);
    }
    if (!gameState.player.moveLeft && !gameState.player.moveRight) {
        shoot();
    }
}

function updateGame() {
    updatePlayer();
    gameState.balloons.forEach(b => b.update());
    gameState.bullets.forEach(b => b.update());
    gameState.bullets = gameState.bullets.filter(b => !b.isOffScreen());
    gameState.particles.forEach(p => p.update());
    gameState.particles = gameState.particles.filter(p => !p.isDead());
    checkCollisions();
    if (gameState.balloons.length === 0) showLevelComplete();
    document.getElementById('stageNumber').textContent = gameState.stage;
    document.getElementById('balloonCount').textContent = gameState.balloons.length;
    document.getElementById('livesCount').textContent = gameState.player.lives;
}

function drawBackground() {
    // Draw background buildings and neon signs
    gameState.backgroundElements.forEach(element => {
        ctx.save();
        ctx.globalAlpha = element.opacity || 0.8;
        
        if (element.type === 'building') {
            ctx.fillStyle = element.color;
            ctx.shadowColor = element.color;
            ctx.shadowBlur = 20;
            ctx.fillRect(element.x, element.y, element.width, element.height);
            
            // Building windows
            ctx.fillStyle = '#ffffff';
            ctx.globalAlpha = 0.1;
            for (let y = element.y + 20; y < element.y + element.height - 20; y += 30) {
                for (let x = element.x + 10; x < element.x + element.width - 10; x += 20) {
                    if (Math.random() > 0.3) {
                        ctx.fillRect(x, y, 8, 12);
                    }
                }
            }
        } else if (element.type === 'sign') {
            element.glow += 0.05;
            const pulse = Math.sin(element.glow) * 0.3 + 0.7;
            
            ctx.globalAlpha = pulse;
            ctx.fillStyle = element.color;
            ctx.shadowColor = element.color;
            ctx.shadowBlur = 30;
            ctx.font = '20px Orbitron';
            ctx.fillText(element.text, element.x, element.y);
        }
        ctx.restore();
    });
}

function drawPlayer() {
    if (gameState.player.invulnerable && Math.floor(Date.now() / 100) % 2) return;
    
    ctx.save();
    
    // Player glow effect
    const glowColor = gameState.player.shield ? '#ff0080' : '#00ffff';
    ctx.shadowColor = glowColor;
    ctx.shadowBlur = gameState.player.shield ? 30 : 20;
    
    // Player ship gradient
    const gradient = ctx.createLinearGradient(
        gameState.player.x - 30, gameState.player.y - 30,
        gameState.player.x + 30, gameState.player.y + 30
    );
    gradient.addColorStop(0, gameState.player.shield ? '#ff0080' : '#00ffff');
    gradient.addColorStop(0.5, '#ffffff');
    gradient.addColorStop(1, gameState.player.shield ? '#ff4060' : '#0080ff');
    
    ctx.fillStyle = gradient;
    ctx.strokeStyle = '#ffffff';
    ctx.lineWidth = 2;
    
    const size = 30;
    ctx.beginPath();
    ctx.moveTo(gameState.player.x, gameState.player.y - size);
    ctx.lineTo(gameState.player.x - size, gameState.player.y + size);
    ctx.lineTo(gameState.player.x + size, gameState.player.y + size);
    ctx.closePath();
    ctx.fill();
    ctx.stroke();
    
    // Shield visual effect
    if (gameState.player.shield) {
        ctx.strokeStyle = '#ff0080';
        ctx.lineWidth = 4;
        ctx.setLineDash([8, 8]);
        ctx.beginPath();
        ctx.arc(gameState.player.x, gameState.player.y, size + 25, 0, Math.PI * 2);
        ctx.stroke();
        ctx.setLineDash([]);
    }
    
    ctx.restore();
}

function drawGame() {
    // Neo-Tokyo cyberpunk background
    const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
    gradient.addColorStop(0, '#0a0a1a');
    gradient.addColorStop(0.3, '#1a1a2e');
    gradient.addColorStop(0.7, '#16213e');
    gradient.addColorStop(1, '#0f0f23');
    ctx.fillStyle = gradient;
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    // Background elements
    drawBackground();
    
    // Cyberpunk floor with neon grid
    const floorGradient = ctx.createLinearGradient(0, canvas.height - 80, 0, canvas.height);
    floorGradient.addColorStop(0, '#1a1a2e');
    floorGradient.addColorStop(1, '#000000');
    ctx.fillStyle = floorGradient;
    ctx.fillRect(0, canvas.height - 80, canvas.width, 80);
    
    // Neon grid floor
    ctx.save();
    ctx.strokeStyle = '#00ffff';
    ctx.lineWidth = 1;
    ctx.globalAlpha = 0.3;
    
    for (let x = 0; x < canvas.width; x += 40) {
        ctx.beginPath();
        ctx.moveTo(x, canvas.height - 80);
        ctx.lineTo(x, canvas.height);
        ctx.stroke();
    }
    
    for (let y = canvas.height - 80; y <= canvas.height; y += 20) {
        ctx.beginPath();
        ctx.moveTo(0, y);
        ctx.lineTo(canvas.width, y);
        ctx.stroke();
    }
    ctx.restore();
    
    // Game objects
    gameState.balloons.forEach(b => b.draw());
    gameState.bullets.forEach(b => b.draw());
    gameState.particles.forEach(p => p.draw());
    drawPlayer();
}

function showLevelComplete() {
    document.getElementById('completedStage').textContent = gameState.stage;
    document.getElementById('balloonsDestroyed').textContent = gameState.balloonsDestroyed;
    document.getElementById('levelComplete').style.display = 'block';
}

function continueToNextLevel() {
    document.getElementById('levelComplete').style.display = 'none';
    gameState.stage++;
    showSlotMachine();
}

function showLevelRestart() {
    document.getElementById('failedStage').textContent = gameState.stage;
    document.getElementById('levelRestart').style.display = 'block';
}

function restartLevel() {
    document.getElementById('levelRestart').style.display = 'none';
    gameState.player.lives = 3;
    gameState.player.x = canvas.width / 2;
    gameState.player.invulnerable = false;
    gameState.bullets = [];
    gameState.particles = [];
    spawnBalloons(gameState.stage);
}

// FIXED: Slot machine with unique skills and proper alignment
let slotSpinAnimations = [];
let finalUpgrades = [];

function showSlotMachine() {
    startSlotSpin();
    document.getElementById('slotMachine').style.display = 'block';
}

function startSlotSpin() {
    const slotOptions = document.getElementById('slotOptions');
    slotOptions.innerHTML = '';
    slotSpinAnimations = [];
    finalUpgrades = [];
    
    document.getElementById('slotInstructions').textContent = 'Scanning cyberware database...';
    
    for (let i = 0; i < 3; i++) {
        const optionDiv = document.createElement('div');
        optionDiv.className = 'slotOption spinning';
        optionDiv.id = `slot${i}`;
        
        optionDiv.innerHTML = `
            <div class="icon">üîß</div>
            <div class="name">SCANNING...</div>
            <div class="desc">Please wait...</div>
        `;
        
        slotOptions.appendChild(optionDiv);
        
        // FIXED: Only spin through available (non-acquired) upgrades
        const availableUpgrades = gameState.allUpgrades.filter(upgrade => 
            !gameState.acquiredSkills.has(upgrade.name)
        );
        
        if (availableUpgrades.length === 0) {
            // If no upgrades available, show a special message
            optionDiv.innerHTML = `
                <div class="icon">‚ú®</div>
                <div class="name">MAXED OUT</div>
                <div class="desc">All systems upgraded</div>
            `;
            optionDiv.classList.remove('spinning');
            continue;
        }
        
        let currentIndex = Math.floor(Math.random() * availableUpgrades.length);
        const spinInterval = setInterval(() => {
            currentIndex = (currentIndex + 1) % availableUpgrades.length;
            const currentUpgrade = availableUpgrades[currentIndex];
            optionDiv.querySelector('.icon').textContent = currentUpgrade.icon;
            optionDiv.querySelector('.name').textContent = currentUpgrade.name;
        }, 100);
        
        slotSpinAnimations.push({ 
            interval: spinInterval, 
            currentIndex: currentIndex,
            availableUpgrades: availableUpgrades
        });
    }
    
    setTimeout(() => stopSlotSpin(0), 1500);
    setTimeout(() => stopSlotSpin(1), 2000);
    setTimeout(() => stopSlotSpin(2), 2500);
    setTimeout(() => enableSlotSelection(), 3000);
}

function stopSlotSpin(slotIndex) {
    if (slotSpinAnimations[slotIndex] && slotSpinAnimations[slotIndex].availableUpgrades) {
        clearInterval(slotSpinAnimations[slotIndex].interval);
        
        const availableUpgrades = slotSpinAnimations[slotIndex].availableUpgrades;
        if (availableUpgrades.length > 0) {
            // FIXED: Ensure unique selection by removing already selected upgrades
            const remainingUpgrades = availableUpgrades.filter(upgrade => 
                !finalUpgrades.some(final => final && final.name === upgrade.name)
            );
            
            if (remainingUpgrades.length > 0) {
                const randomIndex = Math.floor(Math.random() * remainingUpgrades.length);
                const finalUpgrade = remainingUpgrades[randomIndex];
                finalUpgrades[slotIndex] = finalUpgrade;
                
                const slotDiv = document.getElementById(`slot${slotIndex}`);
                if (slotDiv) {
                    slotDiv.classList.remove('spinning');
                    
                    slotDiv.innerHTML = `
                        <div class="icon">${finalUpgrade.icon}</div>
                        <div class="name">${finalUpgrade.name}</div>
                        <div class="desc">${finalUpgrade.desc}</div>
                    `;
                    
                    setTimeout(() => {
                        slotDiv.onclick = () => selectUpgrade(finalUpgrade.name, slotIndex);
                    }, 500);
                }
            }
        }
    }
}

function enableSlotSelection() {
    document.getElementById('slotInstructions').textContent = 'Select enhancement module:';
}

function selectUpgrade(upgradeName, slotIndex) {
    // FIXED: Add to acquired skills to prevent duplicates
    gameState.acquiredSkills.add(upgradeName);
    
    switch(upgradeName) {
        case 'Dual Cannon': gameState.player.doubleShot = true; break;
        case 'Rail Rounds': gameState.player.ricochet = true; break;
        case 'Auto-Burst': gameState.player.fireRate = Math.max(100, gameState.player.fireRate * 0.7); break;
        case 'Force Field':
            gameState.player.shield = true;
            setTimeout(() => gameState.player.shield = false, 15000);
            break;
        case 'Overdrive':
            gameState.player.speedBoost = true;
            setTimeout(() => gameState.player.speedBoost = false, 20000);
            break;
        // Add other upgrade effects as needed
    }
    
    slotSpinAnimations.forEach(anim => {
        if (anim.interval) clearInterval(anim.interval);
    });
    
    document.getElementById('slotMachine').style.display = 'none';
    spawnBalloons(gameState.stage);
}

function gameOver() {
    document.getElementById('finalStage').textContent = gameState.stage;
    document.getElementById('gameOver').style.display = 'block';
}

function restartGame() {
    gameState.stage = 1;
    gameState.balloonsDestroyed = 0;
    gameState.player.x = canvas.width / 2;
    gameState.player.y = canvas.height - 80;
    gameState.player.lives = 3;
    gameState.player.doubleShot = false;
    gameState.player.ricochet = false;
    gameState.player.shield = false;
    gameState.player.speedBoost = false;
    gameState.player.fireRate = 300;
    gameState.player.invulnerable = false;
    gameState.balloons = [];
    gameState.bullets = [];
    gameState.particles = [];
    
    // FIXED: Reset acquired skills on game restart
    gameState.acquiredSkills.clear();
    
    document.getElementById('gameOver').style.display = 'none';
    document.getElementById('levelRestart').style.display = 'none';
    
    slotSpinAnimations.forEach(anim => {
        if (anim.interval) clearInterval(anim.interval);
    });
    slotSpinAnimations = [];
    
    spawnBalloons(1);
}

function gameLoop() {
    updateGame();
    drawGame();
    requestAnimationFrame(gameLoop);
}

// Add roundRect polyfill for older browsers
if (!CanvasRenderingContext2D.prototype.roundRect) {
    CanvasRenderingContext2D.prototype.roundRect = function(x, y, width, height, radius) {
        this.beginPath();
        this.moveTo(x + radius, y);
        this.lineTo(x + width - radius, y);
        this.quadraticCurveTo(x + width, y, x + width, y + radius);
        this.lineTo(x + width, y + height - radius);
        this.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
        this.lineTo(x + radius, y + height);
        this.quadraticCurveTo(x, y + height, x, y + height - radius);
        this.lineTo(x, y + radius);
        this.quadraticCurveTo(x, y, x + radius, y);
        this.closePath();
    };
}

// Initialize and start
initBackground();
spawnBalloons(1);
gameLoop();

</script>
</body>
</html>
